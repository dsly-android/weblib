## Http缓存介绍
#### 目录介绍
- 01.为什么要用缓存
- 02.HTTP缓存机制





### 01.为什么要用缓存
- 缓存对移动端非常重要，使用缓存可以提高用户体验，用缓存的主要在于：
    - 1减少请求次数，较少服务器压力
    - 2本地数据读取更快，让页面不会空白几百毫秒
    - 3在无网络的情况下提供数据
- HTTP缓存是最好的减少客户端服务器往返次数的方案，缓存提供了一种机制来保证客户端或者代理能够存储一些东西，而这些东西将会在稍后的HTTP响应中用到的。(即第一次请求了，到了客户端，缓存起来，下次如果请求还需要一些资源，就不用到服务器去取了)这样，就不用让一些资源再次跨越整个网络了。
    - ![image](https://img-blog.csdnimg.cn/2020032309482190.png)


### 02.HTTP缓存机制
#### 2.1 HTTP报文
- HTTP报文就是客户端和服务器之间通信时发送及其响应的数据块。客户端向服务器请求数据，发送请求(request)报文；服务器向客户端下发返回数据，返回响应(response)报文，报文信息主要分为两部分。
- 1包含属性的头部(header)-------------附加信息(cookie，缓存信息等)，与缓存相关的规则信息，均包含在header中
- 2包含数据的主体部分(body)--------------HTTP请求真正想要传输的部分


#### 2.2 缓存分类
- (1)按照"端“”分类。缓存可以分为
    - 1、服务器缓存，其中服务器缓存又可以分为服务器缓存和反向代理服务器缓存，其实广泛使用的CSN也是一种服务端缓存，目的都是让用户的请求走"捷径"，并且都是缓存图片、文件等静态资源。
    - 2、客户端缓存，客户端缓存则一般是只浏览器缓存，目的就是加速各种静态资源的访问，想想淘宝，京东，百度随便一个网页都是上百请求，每天PV都是上亿的，如果没有缓存，用户体验会急剧下降，同时服务器压力巨大。
- (2) 按照"是否想服务器发起请求，进行对比"分类。可以分为:
    - 1 强制缓存(不对比缓存)
    - 2 对比缓存
- 已存在缓存数据时,仅基于强制缓存，请求数据流程如下：
    - ![image](https://img-blog.csdnimg.cn/20200323095303805.png)
- 已存在缓存数据时，仅基于对比缓存，请求数据的流程如下：
    - ![image](https://img-blog.csdnimg.cn/20200323095333991.png)
- 可以看到两类缓存规则的不同，强制缓存如果生效，则不再和服务器交互了，而对比缓存不惯是否生效，都需要和服务器发生交互。
- 通过上面了解到，在缓存数据未失效的情况下，可以直接使用缓存数据，那么客户端是怎么判断数据是否失效的？同理，什么时候采用强制缓存，而什么时候又采用对比缓存，这里面客户端是怎么和服务器进行交互的？上面也说道，缓存规则是包含在响应header里面的。莫非所有的交互在header里面？


#### 2.3 请求头header中有关缓存的设置
##### 2.3.1 expires
- 在HTTP/1.0中expires的值围服务器端返回的到期时间，即下一次请求时，请求时间小于服务器返回的到期时间，直接使用缓存数据，这里面有个问题，由于到期时间是服务器生成的，但是客户端的时间可能和服务器有误差，所以这就会导致误差，所以到了HTTP1.1基本上不适用expires了，使用Cache-Control替代了expires。


##### 2.3.2 Cache-Control
- Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age、no-store、默认是private。
- 响应头部 意义
    - Cache-Control：public 响应被公有缓存，移动端无用
    ```
    响应头部	意义
    Cache-Control：public	响应被共有缓存，移动端无用
    Cache-Control：private	响应被私有缓存，移动端无用
    Cache-Control：no-cache	不缓存
    Cache-Control：no-store	不缓存
    Cache-Control：max-age=60	60秒之后缓存过期
    ```
    - (PS：在浏览器里面，private 表示客户端可以缓存，public表示客户端和服务器都可以缓存)
- 举个例子。入下图：
    - ![image](https://img-blog.csdnimg.cn/2020032310025385.png)
- 图中Cache-Control仅指定了max-age所以默认是private。缓存时间是31536000，也就是说365内的再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。


##### 2.3.3 Last-Modified/If-Modified-Since
- 上面提到了对比缓存，顾名思义，需要进行比较判断是否可以使用缓存，客户端第一次发起请求时，服务器会将缓存标志和数据一起返回给客户端，客户端当二者缓存至缓存数据库中。再次其你去数据时，客户端将备份的缓存标志发送给服务器，服务器根据标志来进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。
- 上面说到了对比缓存的流程，那么具体又是怎么实现的那？
- Last-Modified
    - 是通过Last-Modified/If-Modified-Since来实现的，服务器在响应请求时，告诉浏览器资源的最后修改时间。
    - ![image](https://img-blog.csdnimg.cn/20200323102443354.png)
- If-Modified-Since
    - 再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回最远的最后修改时间。服务器收到请求后发现有If-Modified-Since则与被请求资源的最后修改时间进行对比。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整个内容，返回状态码是200.如果资源的最后修改时间小于或者等于If-Modified-Since，说明资源没有修改，则响应状态码为304，告诉客户端继续使用cache.
    - ![image](https://img-blog.csdnimg.cn/20200323102602201.png)


##### 2.3.4 ETag/If-None-Match(优先级高于Last-Modified/If-Modified-Since)
- Etag:服务响应请求时，告诉客户端当前资源在服务器的唯一标识(生成规则由服务器决定)
    - ![image](https://img-blog.csdnimg.cn/20200323102818941.png)
- If-None-Match:
    - 再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。服务器收到请求后发现有头部If-None-Match则与被请求的资源的唯一标识进行对比，不同则说明资源被改过，则响应整个内容，返回状态码是200，相同则说明资源没有被改动过，则响应状态码304，告知客户端可以使用缓存
    - ![image](https://img-blog.csdnimg.cn/20200323102915430.png)
- 正式使用时按需求也许只包含其中部分字段，客户端要根据这些信息存储这次请求信息，然后在客户端发起的时间内检查缓存，遵循下面的步骤
    - ![image](https://img-blog.csdnimg.cn/20200323102940765.png)












